<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --hex-width: 32px;
      --hex-height: 24px;
    }

    body {
      -webkit-font-smoothing: none;
      image-rendering: pixelated;
      /* zoom: 2; */
    }

    #main {
      height: 144px;
      width: 300px;
      padding: 16px 0 0 44px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: absolute;
      top: 0;
      left: 0;
    }

    #message {
      height: 80px;
      width: 320px;
      background-color: lightgreen;
    }

    .hex::before {
      background-color: lightgray;
      width: calc(var(--hex-width) - 1px);
      height: calc(var(--hex-height) - 1px);
      clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
      position: absolute;
      content: '';
      z-index: 0;
      /* top: 1px;
      left: 1px; */
    }

    .hex {
      background-color: black;
      width: var(--hex-width);
      height: var(--hex-height);
      clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
      position: relative;
      z-index: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .label {
      z-index: 1;
      position: relative;
      font-size: 0.6rem;
    }

    .start::before {
      background-color: lightpink;
    }

    .end::before {
      background-color: mediumseagreen;
    }

    .path::before {
      background-color: steelblue;
    }

    .hidden {
      background-color: transparent;
    }

    .hidden::before {
      background-color: transparent;
    }

    #container {
      display: flex;
      flex-direction: column;
      width: 320px;
      height: 240px;
      background-color: lightblue;
    }

    .row {
      display: flex;
      column-gap: calc(var(--hex-width) / 2);
      width: 280px;
    }

    .row:nth-child(even) {
      margin-left: calc(var(--hex-width) * 0.75);
    }

    .row:not(:first-child) {
      margin-top: calc(var(--hex-height) / -2);
    }

    .wrapper {
      position: relative;
      width: 320px;
      height: 160px;
    }

    .cursor {
      position: absolute;
      top: 0;
      left: 0;
      width: 1em;
      height: 1em;
      color: red;
    }
  </style>
  <title>プロトタイプ</title>
</head>

<body>
  <div id="container">
    <div class="wrapper">
      <div id="main">
        <div class="row" v-for="y in row">
          <div class="hex" v-for="x in column" :data-x="x" :data-y="y" :class="{
          hidden: isHidden(x, y),
          start: isSelected(start, x, y),
          end: isSelected(end, x, y),
          path: isPath(x, y)
        }">
            <span class="label" :style="{
              display: isHidden(x, y) ? 'none' : 'inline',
            }">{{x}},{{y}}</span>
          </div>
        </div>
      </div>
      <div class="cursor" :style="{
        top: cursorY * 24 * 0.5 + 'px',
        left: cursorX * 32 * 1.5 + cursorY % 2 * 32 * 0.75 + 52 + 'px'
      }">▼</div>
    </div>
    <div id="message">
      test: {{cursorX}}, {{cursorY}}<br />
      start: {{start.x}}, {{start.y}}, end: {{end.x}}, {{end.y}}<br />
      <span v-for="k in keyList">{{k}}&nbsp;</span>
    </div>
  </div>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

  <script>
    const { createApp, ref, computed } = Vue;

    createApp({
      setup() {
        const row = 9;
        const column = 5;
        const keyViewTime = 1000;
        const cursorX = ref(1);
        const cursorY = ref(0);
        const keyList = ref([]);
        const start = ref({ x: 1, y: 5 });
        const end = ref({ x: 2, y: 1 });
        let isBottom = false;

        const isHidden = (x, y) => {
          // まず、右端を削る
          if (x === column && y % 2 == 0) {
            return true;
          }
          // 左上
          if (x === 1 && y === 1) {
            return true;
          }
          // 右上
          if (x === column && y === 1) {
            return true;
          }
          // 左下
          if (x === 1 && y === row) {
            return true;
          }
          // 右下
          if (x === column && y === row) {
            return true;
          }
          return false;
        }

        const isSelected = (point, x, y) => {
          return (point.x === x - 1 && point.y === y - 1);
        }

        const isPath = (x, y) => {
          return !!pathList.value.find((point) => {
            console.log(point, x, y);
            return isSelected(point, x, y);
          })
        }

        const pathList = computed(() => {
          if (start.value.x + start.value.y > 0 && end.value.x + end.value.y > 0) {
            // startとendが入ってたら
            // TODO
            return [{ x: 2, y: 4 }, { x: 2, y: 2 }]
          }
        })

        const removeKey = () => {
          keyList.value.pop();
        }

        const VERTICAL_STEP = 2;
        const TOP_BOUNDARY = 0;
        const BOTTOM_BOUNDARY = row - 1;
        const CORNER_TOP_WRAP_POINT = 2;
        const CORNER_BOTTOM_WRAP_POINT = row - 3;

        const isEdgeColumn = () => {
          return (cursorX.value === 0 || cursorX.value === column - 1) && cursorY.value % 2 == 0;
        };

        const moveUp = () => {
          isBottom = false;
          cursorY.value -= VERTICAL_STEP;
          if (cursorY.value < TOP_BOUNDARY) {
            cursorY.value = BOTTOM_BOUNDARY + cursorY.value % 2;
          }
          // 四隅対応
          if (isEdgeColumn()) {
            console.log(cursorY.value, CORNER_TOP_WRAP_POINT);
            if (cursorY.value < CORNER_TOP_WRAP_POINT) {
              cursorY.value = CORNER_BOTTOM_WRAP_POINT;
            }
          }
        };

        const moveDown = () => {
          isBottom = false;
          cursorY.value += VERTICAL_STEP;
          if (cursorY.value > BOTTOM_BOUNDARY) {
            cursorY.value = TOP_BOUNDARY + cursorY.value % 2;
          }
          // 四隅対応
          if (isEdgeColumn()) {
            if (cursorY.value > CORNER_BOTTOM_WRAP_POINT) {
              cursorY.value = CORNER_TOP_WRAP_POINT;
            }
          }
        };

        const moveLeft = () => {
          const isOddRow = cursorY.value % 2 === 0;
          if (cursorY.value === row - 1) {
            isBottom = true;
          }
          // 四隅対応
          if (cursorX.value === 0 && cursorY.value === 1) {
            cursorY.value++;
            return;
          }
          if (cursorX.value === 0 && cursorY.value === row - 2) {
            cursorY.value--;
            return;
          }
          if (isOddRow) {
            // 奇数行の場合
            cursorX.value--;
            if (cursorX.value < 0) {
              cursorX.value = column - 1;
            } else if (isBottom) {
              cursorY.value--;
            } else {
              cursorY.value++;
            }
          } else {
            // 偶数行の場合
            if (isBottom) {
              cursorY.value++;
            } else {
              cursorY.value--;
            }
          }
        };

        const moveRight = () => {
          if (cursorY.value === row - 1) {
            isBottom = true;
          }
          // 四隅対応
          if (cursorX.value === column - 2 && cursorY.value === 1) {
            cursorX.value++;
            cursorY.value++;
            return;
          }
          if (cursorX.value === column - 2 && cursorY.value === row - 2) {
            cursorX.value++;
            cursorY.value--;
            return;
          }
          if (cursorY.value % 2 === 0) {
            // 奇数行の場合
            if (cursorX.value === column - 1) {
              // 反転する
              cursorX.value = 0;
            } else if (isBottom) {
              // 最下段での移動の場合
              cursorY.value--;
            } else {
              cursorY.value++;
            }
          } else {
            // 偶数行の場合
            cursorX.value++;
            if (isBottom) {
              cursorY.value++;
            } else {
              cursorY.value--;
            }
          }
        };

        const onKeyDown = (e) => {
          const keyMap = {
            ArrowUp: { func: moveUp, symbol: '↑' },
            ArrowDown: { func: moveDown, symbol: '↓' },
            ArrowLeft: { func: moveLeft, symbol: '←' },
            ArrowRight: { func: moveRight, symbol: '→' },
          };

          const action = keyMap[e.key];
          if (!action) {
            return;
          }

          action.func();
          keyList.value.unshift(action.symbol);
          setTimeout(removeKey, keyViewTime);
        }

        return {
          row,
          column,
          cursorX,
          cursorY,
          onKeyDown,
          isHidden,
          keyList,
          start,
          end,
          isSelected,
          pathList,
          isPath
        }
      },
      mounted() {
        document.addEventListener('keydown', this.onKeyDown);
      },
      beforeUnmount() {
        document.removeEventListener('keydown', this.onKeyDown);
      }
    }).mount('#container');
  </script>
</body>

</html>